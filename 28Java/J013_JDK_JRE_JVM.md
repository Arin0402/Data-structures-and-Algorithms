<!-- https://www.youtube.com/watch?v=s7UgQ7_1KQY -->

JDK > JRE > JVM

### JDK

The Java Development Kit (JDK) is a cross-platformed software development environment that offers a collection of tools and libraries necessary for developing Java-based software applications and applets. It is a core package used in Java, along with the JVM (Java Virtual Machine) and the JRE (Java Runtime Environment).Oracle has the following JDK variants.

1. JDK standard edition
2. JDK Enterprise edition
3. JDK micro edition

### JRE

**JRE** stands for **Java Runtime Environment**.

---

### 🧾 Definition:

> JRE is the **software package** that provides everything needed to **run Java applications**.

---

### 🧰 It Includes:

- **JVM (Java Virtual Machine)** – runs the bytecode
- **Core libraries** – essential Java class files (like `java.lang`, `java.util`)
- **Other runtime components**

---

### ❌ It does **not** include:

- Development tools like `javac` (Java compiler)
  ➤ For that, you need the **JDK** (Java Development Kit)

---

### 🧠 Summary:

> **JRE = JVM + Libraries**
> It lets you **run** Java programs, but not **develop** them.

### JVM

> JVM is a part of Java that **executes Java bytecode** and makes Java **platform-independent**.JVM is the one that actually calls the main method present in a java code. JVM is a part of JRE(Java Runtime Environment).JIT (Just-In-Time) compiler is part of the JVM. JIT compiles frequently used bytecode into native machine code at runtime, improving performance.

### 🧰 Responsibilities of JVM:

- **Loads** `.class` files (bytecode)
- **Verifies** and **executes** the code
- **Manages memory** (garbage collection)
- Handles **security** and **exceptions**

Thanks to JVM, Java programs can run on any machine that has a JVM installed — regardless of OS.
JVM is the engine that runs Java programs, converting bytecode into machine code for your system.

### What is a class loader

A class loader in java is a subsystem of java virtual machine, dedicated to load class files when a program is executed, classLoader is the first one to load the executable file. Java has bootstrap, extenstion and application class loader

### What are the memory allocations available in java ?

1. class memory
2. heap memory
3. stack memory
4. Program counter memory
5. Native method stack memory

### will the program run if i write static public void main ?

Yes, the program will successfully execute if written so. Because, in java, there is no specific rule for order of specifiers.

### Do JRE compiles the java source code to bytecode?

No, the Java Runtime Environment (JRE) does not compile Java source code to bytecode. The JRE is responsible for running Java applications, but it does not perform compilation.

Compilation from Java source code to bytecode is done by the Java Development Kit (JDK), specifically by the `javac` compiler, which is part of the JDK. Here's how the process works:

1. **Java Source Code**: You write your Java source code in plain text files with the `.java` extension.

2. **Compilation**: To compile your Java source code into bytecode, you use the `javac` compiler provided by the JDK. This compiler reads your `.java` files and generates corresponding `.class` files containing the bytecode.

   ```bash
   javac YourJavaFile.java
   ```

3. **Bytecode**: The generated bytecode is a platform-independent, low-level representation of your Java program. It consists of instructions that the Java Virtual Machine (JVM) can execute.

4. **Java Runtime Environment (JRE)**: The JRE includes the JVM, which is responsible for executing the bytecode. When you run a Java application (e.g., `java YourJavaClass`), the JRE loads the bytecode and executes it within the JVM.

So, in summary, the JRE's main role is to run Java bytecode, not to compile Java source code. Compilation is done by the JDK's `javac` compiler during the development phase, and the resulting bytecode is then executed by the JRE at runtime.

### Synchronization - It is a technique used to maintain resources in a resource sharing environment so that race conditions may not occur.

### why is java code compiled to byte code first and then machine code. Why can't we directly create machine code

Java code is compiled to bytecode first, and then that bytecode is executed by the Java Virtual Machine (JVM) rather than being directly compiled to machine code for several reasons:

1. **Platform Independence:**
   Java was designed to be platform-independent. By compiling code to bytecode, which is a low-level representation of the code, Java achieves portability. The bytecode can be executed on any platform that has a compatible JVM without modification. If Java compiled directly to machine code, it would be tied to a specific hardware architecture, making it less versatile.

2. **Optimization:**
   The JVM has the capability to perform Just-In-Time (JIT) compilation. This means that it can optimize the bytecode for the specific machine it's running on at runtime. The JVM can analyze how the program behaves during execution and make performance improvements dynamically. This results in better runtime performance compared to statically compiled machine code, which may not be optimized for the specific hardware.

3. **Portability and Distribution:**
   Distributing bytecode rather than machine code simplifies software distribution. Developers can distribute a single bytecode version of their program that works on various platforms, reducing the need for maintaining multiple machine code versions.

### Do Jar file contains bytecode or machinecode

### ✅ A **JAR file** contains **Java bytecode**, **not machine code**.

---

### 🔍 What is a JAR file?

> A **JAR** (Java ARchive) file is a compressed package that bundles together:

- Compiled `.class` files (✅ bytecode)
- Resource files (images, config files, etc.)
- Optional `META-INF/MANIFEST.MF` file

---

### 🧠 Key Point:

- The `.class` files inside a JAR contain **bytecode**, which is interpreted or compiled to **machine code at runtime** by the **JVM (with help of JIT)**.

---

### ✅ Summary:

> **JAR = Bytecode + Resources**,
> Not machine code — that’s generated **by the JVM at runtime**.

### **JRE (Java Runtime Environment)**

- **Definition**: Provides an environment to run Java applications.
- **Components**:
  - **JVM (Java Virtual Machine)** – Executes Java bytecode.
  - **Core Libraries** – Essential classes like `java.lang`, `java.io`, etc.
  - **Runtime Libraries** – Support utilities like JDBC, JavaFX, etc.
- **Does NOT include** the Java Compiler (`javac`).

---

### **JVM (Java Virtual Machine)**

- **Definition**: A virtual processor that interprets and runs Java bytecode.
- **Key Responsibilities**:
  1. **Class Loading** – Uses the ClassLoader to load `.class` files.
  2. **Bytecode Verification** – Ensures security and correctness.
  3. **Execution** – Converts bytecode into machine code via:
     - **Interpreter** (line-by-line execution)
     - **JIT Compiler** (compiles frequently used code to native machine code for faster execution)
  4. **Memory Management**:
     - **Heap** → Stores objects.
     - **Stack** → Stores method calls and local variables.
     - **Method Area** → Stores class metadata, static variables.
  5. **Garbage Collection (GC)** – Automatically reclaims unused memory.

---

### **Key Differences**

| Feature           | JRE                             | JVM                       |
| ----------------- | ------------------------------- | ------------------------- |
| Purpose           | Runs Java applications          | Executes Java bytecode    |
| Includes          | JVM + Libraries                 | Part of JRE               |
| Memory Management | Handles runtime libraries & JVM | Manages Heap, Stack, GC   |
| Compilation       | Does not compile                | Uses JIT for optimization |

Let me know if you need more details! 🚀
